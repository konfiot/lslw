// Context
var canvas = document.getElementById("myCanvas");
var ctx = canvas.getContext("2d");
var gameWindow = canvas.getBoundingClientRect();
var canvasMarginLeft = gameWindow.left;
var canvasMarginTop =  gameWindow.top;

canvas.width = document.body.clientWidth; //document.width is obsolete
canvas.height = document.body.clientHeight; //document.height is obsolete

// Colors
var whiteColor = "rgb(255, 255, 255)";
var whiteTransparentColor = "rgba(255, 255, 255, 0.2)";
var whiteSemiColor = "rgba(255, 255, 255, 0.6)";
var backgroundColor = "rgb(30, 8, 54)";
// var blueColor = "rgb(35, 95, 253)";
// var blueEdge = "rgb(109, 127, 255)";
var distantStarColor = "rgb(65, 15, 115)";
var colorList = [];

var T = 0;
var shipSpeed = 70; // px per second

/*
Handles the mouse
*/
function Mouse() {
	this.x = 0;
	this.y = 0;
	this.worldX = 0;
	this.worldY = 0;

	this.isMouseDown = false;
	this.oldMouseDown = false;
	this.lastClickedX = 0;
	this.lastClickedY = 0;
}

// When the mouse button is pressed
Mouse.prototype.downHandler = function (e) {
	if (!this.isMouseDown) {
		this.lastClickedX = this.x;
		this.lastClickedY = this.y;
	}
	this.isMouseDown = true;
	player.update();
};

// When the mouse button is released
Mouse.prototype.upHandler = function (e) {
	this.isMouseDown = false;
	player.update();
};

// When the mouse wheel is rotated
Mouse.prototype.wheelHandler = function (e) {
	var delta = 0;

	if (e.wheelDelta) { // IE/Opera.
		delta = -(e.wheelDelta / 120);
	} else if (e.detail) { // Mozilla
		delta = e.detail / 3;
	}

	// Set boundaries
	var newScale = player.scale * (1 + delta * 0.05);

	if (newScale < 3 || delta < 0) {
		player.scale = newScale;
	} else {
		// Custom formula
		player.scale = player.scale + 0.15 * delta * Math.exp(-3 * 0.1) * Math.exp(-player.scale * 0.1);
	}

	if (e.preventDefault) {
		e.preventDefault();
	}

	e.returnValue = false;

	worldMousePosition();
};

// When the mouse is moved.
// A threshold need to be crossed before the camera actually moves
Mouse.prototype.moveHandler = function (e) {
	var _mouseX = e.pageX - canvasMarginLeft;
	var _mouseY = e.pageY - canvasMarginTop;
	var dx = this.x - _mouseX;
	var dy = this.y - _mouseY;
	var deltaCenter = Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));

	if (this.isMouseDown && deltaCenter > 3) {
		player.mouseDownMoved(dx, dy);
	}

	player.update();

	this.x = _mouseX;
	this.y = _mouseY;

	worldMousePosition();
};

/*
A simple structure for the satellites
*/
function Satellite(x, y, value) {
	this.x = x;
	this.y = y;
	this.value = value;

	this.radius = 2 + 2 * this.value;
}

/*
The player's state is embedded in this class. It handles the ships as well
*/
function Player(id) {
	this.id = id;

	this.hoveredStar = -1;
	this.selectedStar = -1;
	this.clickedStar = -1;
	this.previousSelectedStar = -1;
	this.previousClickedStar = -1;
	this.isDragging = false;

	this.hoveredSatellite = -1;

	this.centerX = 0;
	this.centerY = 0;
	this.scale = 1;

	// Animation
	// [star number, start time, progression]
	this.selectionAnimation = [];
}

Player.prototype.newSelection = function (starId) {
	this.previousSelectedStar = this.selectedStar;
	this.selectedStar = starId;

	if (this.selectionAnimation.length > 0) {
		this.selectionAnimation[this.selectionAnimation.length - 1][1] = globalTimer;
	}

	if (this.selectedStar >= 0) {
		this.selectionAnimation.push([this.selectedStar, globalTimer, 0]);
	}
};

// Called when the mouse state changes
Player.prototype.update = function () {
	// Update animation

	for (var i = this.selectionAnimation.length - 1; i >= 0 ; i--) {
		// Needs to be animated ?
		if (this.selectionAnimation[i][0] != this.selectedStar) {
			dt = globalTimer - this.selectionAnimation[i][1];

			// Still animated
			if (dt < 500) {
				this.selectionAnimation[i][2] = dt / 500;
			} else {
				this.selectionAnimation.splice(i, 1);
			}
		}
	}

	// Update which star is hovered
	this.hoveredStar = -1;

	for (var j = 0; j < net.nStars; j++) {
		var radiusStar2 =	Math.pow(mouse.worldX - net.starList[j].x, 2) +
							Math.pow(mouse.worldY - net.starList[j].y, 2);

		if (radiusStar2 < Math.pow(net.starList[j].radius * 1.5 + 10 / player.scale, 2)) {
			this.hoveredStar = j;
			j = net.nStars; // Stop loop
		}
	}

	// Update which star is selected

	if (mouse.isMouseDown && !this.dragging && this.hoveredStar >= 0) {
		this.previousClickedStar = this.clickedStar;
		this.clickedStar = this.hoveredStar;

		if (net.starList[this.hoveredStar].id == this.id) {
			this.newSelection(this.hoveredStar);
		}
	}
	

	// If clicked out a star, deselect

	if (this.hoveredStar < 0 && mouse.isMouseDown) {
		delta = Math.pow(mouse.lastClickedX - mouse.x, 2) + Math.pow(mouse.lastClickedY - mouse.y, 2);

		if (delta < 2) {
			this.newSelection(-1);
			this.clickedStar = -1;
		}
	}

	// Is the mouse still dragging ?

	if (!mouse.isMouseDown) {
		if (this.dragging && this.hoveredStar >= 0 &&
			this.selectedStar >= 0 && this.hoveredStar != this.selectedStar) {
			// TODO Test if possible
			net.automationList.push([this.selectedStar, this.hoveredStar]);
			this.newSelection(-1);
			this.clickedStar  = -1;
		}
		this.dragging = false;
	} else {
		if (this.hoveredStar >= 0) {
			this.dragging = true;
		}
	}

	// If the player whishes to, a ship is sent
	if (this.clickedStar >= 0 && this.previousClickedStar >= 0 &&
		this.previousClickedStar != this.clickedStar && net.starList[this.previousClickedStar].id == this.id) {
		var p = net.starList[this.previousClickedStar].points;

		if (p > 0) {
			net.addNewShip(this.previousClickedStar, this.clickedStar, p);
			net.starList[this.previousClickedStar].setPoints(0);
		}

		this.newSelection(-1);
		this.clickedStar = -1;
	}

	// Update which satellite is hovered
	// NEED OPTIMIZATION
	this.hoveredSatellite = -1;

	for (var k = 0; k < net.nSatellites; k++) {
		var radiusSat2 =	Math.pow(mouse.worldX - net.satelliteList[k].x, 2) +
							Math.pow(mouse.worldY - net.satelliteList[k].y, 2);

		if (radiusSat2 < Math.pow(net.satelliteList[k].radius * 1.5 + 10 / player.scale, 2)) {
			this.hoveredSatellite = k;
			k = net.nSatellites; // Stop loop
		}
	}
};

// If the player is not willing to drag, change the view
Player.prototype.mouseDownMoved = function (mouseDeltaX, mouseDeltaY) {
	if (!this.dragging) {
		this.centerX += mouseDeltaX / this.scale;
		this.centerY += mouseDeltaY / this.scale;
	}
};

Player.prototype.draw = function () {
	// Draws an aura around the hovered star
	if (this.hoveredStar >= 0) {
		var hStar = net.starList[this.hoveredStar];

		ctx.save();

		translate(hStar.x, hStar.y);
		ctx.lineWidth = 6;
		ctx.shadowColor = colorList[hStar.id][1];
		ctx.shadowBlur = 12;

		ctx.beginPath();
		ctx.arc(0, 0, hStar.radius, 0, Math.PI * 2);
		ctx.fill();
		ctx.stroke();

		ctx.restore();
	}

	// Draws an aura around the hovered satellite
	if (this.hoveredSatellite >= 0) {
		var hSat = net.satelliteList[this.hoveredSatellite];

		ctx.save();

		translate(hSat.x, hSat.y);
		ctx.lineWidth = 6;
		ctx.strokeStyle = whiteColor;
		ctx.shadowColor = whiteColor;
		ctx.shadowBlur = 12;

		ctx.beginPath();
		ctx.arc(0, 0, hSat.radius, 0, Math.PI * 2);
		ctx.fill();
		ctx.stroke();

		ctx.restore();
	}

	// Draws the selection cursor
	for (var i = 0; i < this.selectionAnimation.length ; i++) {
		var current = this.selectionAnimation[i];
		var s = net.starList[current[0]];
		var inc = T * 0.01;
		var r = s.radius + 5;

		ctx.save();

		translate(s.x, s.y);
		ctx.strokeStyle = "rgba(255, 255, 255, " + String(0.6 * (1 - current[2] * current[2])) + ")";
		ctx.lineWidth = 10 - current[2] * 5;
		ctx.setLineDash([Math.PI / 3 * r, Math.PI / 6 * r]);
		ctx.shadowColor = whiteSemiColor;
		ctx.shadowBlur = 8;

		ctx.beginPath();
		ctx.arc(0, 0, r, inc, Math.PI * 2 + inc);
		ctx.stroke();
		ctx.closePath();

		ctx.restore();
	}
};

/*
Here goes the map generator.
*/

generateStars = function (size) {
	starList = [];

	for (var i = -size + 1; i < size; i++) {
		for (var j = -size + 1; j < size; j++) {
			starList.push(new Star(parseInt(Math.random() * 3),
									parseInt(350 * (i + Math.random() * 0.5 - 0.25)),
									parseInt(350 * (j + Math.random() * 0.5 - 0.25)),
									parseInt(Math.random() * 10)));
		}
	}

	return starList;
};

generateSatellites = function (nSat, size) {
	satelliteList = [];

	for (var i = 0; i < nSat; i++) {
		satelliteList.push(new Satellite(parseInt((Math.random() * 2 - 1) * size),
							parseInt((Math.random() * 2 - 1) * size),
							parseInt(Math.random() * 3 + 2)));
	}

	return satelliteList;
};

// Transltates the content to the viewer position
function translate(x, y) {
	ctx.translate(-player.centerX + x, -player.centerY + y);
}

// Compute the position of the mouse in world coordinates
worldMousePosition = function () {
	mouse.worldX = player.centerX + (mouse.x - canvas.width / 2) / player.scale;
	mouse.worldY = player.centerY + (mouse.y - canvas.height / 2) / player.scale;
};

function generateColor(n) {
	var mainColor = "hsl(" + String(n) + ", 84%, 51%)";
	var edgeColor = "hsl(" + String(n) + ", 76%, 67%)";

	return [mainColor, edgeColor];
}

// Computes the anchor point, the angle and the length of a connexion
function computeBridge(star1, star2) {
	var dx = star2.x - star1.x;
	var dy = star2.y - star1.y;
	var L = Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));
	var x = dx * star1.radius / L + star1.x;
	var y = dy * star1.radius / L + star1.y;

	var theta = Math.acos(dx / L);

	if (dy < 0) {
		theta = -theta;
	}

	L -= star1.radius + star2.radius;

	return [x, y, theta, L];
}

// Goes from one star to a certain point in space
function computeLink(star1, x2, y2) {
	var dx = x2 - star1.x;
	var dy = y2 - star1.y;
	var L = Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));
	var x = dx * star1.radius / L + star1.x;
	var y = dy * star1.radius / L + star1.y;

	var theta = Math.acos(dx / L);

	if (dy < 0) {
		theta = -theta;
	}

	return [x, y, theta, L];
}

// Draw ships, works for different size : ships between stars or to get points
function drawShip(id, x, y, theta, val, factor, highlight) {
	ctx.save();

	var c = Math.cos(theta);
	var s = Math.sin(theta);

	translate(x, y);
	ctx.scale(factor, factor);
	ctx.fillStyle = colorList[id][0];

	if (highlight) {
		ctx.shadowColor = whiteSemiColor;
		ctx.shadowBlur = 12;
	}

	ctx.beginPath();
	ctx.moveTo(-15 * s, 15 * c);
	ctx.lineTo(35 * c, 35 * s);
	ctx.lineTo(15 * s, -15 * c);
	ctx.lineTo(-10 * c, -10 * s);
	ctx.fill();

	if (val !== 0) {
		ctx.font = "lighter 25px arial";
		ctx.fillStyle = whiteSemiColor;
		ctx.textAlign = "center";
		ctx.textBaseline = "middle";
		ctx.fillText(val, 30 * s, -30 * c);
	}

	ctx.restore();
}

/*
Handles the background, made of distant stars with depth effect.
When the center moves, outbound stars are replaces with others.
*/
function SpaceBackground(n) {
	this.nDistantStars = n;
	this.distantStars = [];

	for (var i = 0; i < this.nDistantStars; i++) {
		var distantFactor = Math.random() * 0.1 + 0.05;
		var radius = Math.random() * 3 + 4;
		var x = (Math.random() * 5 - 2.5) * canvas.width;
		var y = (Math.random() * 5 - 2.5) * canvas.height;
		this.distantStars.push([x, y, radius, distantFactor]);
	}

	// Create a star outside the screen
	this.createOutboundDistantStar = function () {
		var distantFactor = Math.random() * 0.1 + 0.05;
		var _x = Math.random() * 3;
		var _y = 0;

		// Create a star arroud the screen, not within, in a 3x3 box

		if (_x < 1 || _x > 2) {
			_y = Math.random() * 3;
		} else {
			_y = Math.random();

			if (Math.random() < 0.5) {
				_y += 2;
			}
		}

		var x = (_x - 1.5) * canvas.width / player.scale + player.centerX * distantFactor;
		var y = (_y - 1.5) * canvas.height / player.scale + player.centerY * distantFactor;

		// Radius of the distant star
		var radius = Math.random() * 3 + 4;

		return [x, y, radius, distantFactor];
	};

	// Draw the whole space on screen and handle the outbound stars
	this.draw = function () {
		var offScreenStars = [];

		// If inbound, draw. Else, mark the star
		ctx.save();

		if (player.scale > 0.50) {
			// Normal color
			ctx.fillStyle = "rgb(65, 15, 115)";
		} else if (player.scale < 0.30) {
			// Invisible
			ctx.fillStyle = backgroundColor;
		} else {
			// Fade
			var t = (player.scale - 0.3) / 0.2;

			ctx.fillStyle = "rgb(" +	parseInt(30 + 35 * t) + "," +
										parseInt(8 + 7 * t) + "," +
										parseInt(54 + 61 * t) + ")";
		}

		for (var i = 0; i < this.nDistantStars; i++) {
			var distantFactor = this.distantStars[i][3];
			var x = this.distantStars[i][0] - player.centerX * distantFactor;
			var y = this.distantStars[i][1] - player.centerY * distantFactor;

			if (x < canvas.width * 1.5 &&
				x > -canvas.width * 1.5 &&
				y > -canvas.height * 1.5 &&
				y < canvas.height * 1.5) {

				ctx.beginPath();
				ctx.arc(x, y, this.distantStars[i][2], 0, Math.PI * 2);
				ctx.fill();

			} else {
				offScreenStars.push(i);
			}
		}
		ctx.restore();

		// Replace outboud stars with others
		for (var j = 0; j < offScreenStars.length; j++) {
			this.distantStars[offScreenStars[j]] = this.createOutboundDistantStar();
		}
	};
}

/*

*/
function Dot(x, y, points) {
	this.x = x;
	this.y = y;
	this.points = points;

	this.radius = 2 + 2 * this.points;
	this.hover = false;
	this.star = [];
	// s1, Ox, Oy, R, alpha, alpha0, gamma, id
	this.shipList = [];
}

Dot.prototype.update = function (dt) {
	for (var i = this.shipList.length - 1; i >= 0; i--) {
		this.shipList[i][4] -= shipSpeed * dt / this.shipList[i][3];

		if (this.shipList[i][4] < -this.shipList[i][5] - Math.PI) {
			var p = net.starList[this.shipList[i][0]].points + this.points + 1;
			net.starList[this.shipList[i][0]].setPoints(p);
			this.shipList.splice(i, 1);
		}
	}
};

Dot.prototype.draw = function () {
	ctx.save();

	translate(this.x, this.y);
	ctx.fillStyle = whiteColor;
	ctx.shadowColor = whiteColor;
	ctx.strokeStyle = whiteSemiColor;
	ctx.lineWidth = 4;

	// Blur if hovered
	if (!this.hover) {
		ctx.shadowBlur = 5;
	} else {
		ctx.shadowBlur = 18;
	}

	ctx.beginPath();
	ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
	ctx.fill();
	ctx.stroke();

	ctx.restore();

	for (var i = 0; i < this.shipList.length; i++) {
		var theta = this.shipList[i][6] - this.shipList[i][4] + Math.PI;
		var e = Math.PI - this.shipList[i][6] - this.shipList[i][4];
		var R = this.shipList[i][3];

		var x = this.x + this.shipList[i][1] + R * Math.cos(e);
		var y = this.y + this.shipList[i][2] + R * Math.sin(e);

		var highlight = false;

		if (this.shipList[i][4] < -Math.PI * 0.5) {
			highlight = true;
		}

		drawShip(this.shipList[i][7], x, y, theta, 0, 0.5, highlight);
	}
};

Dot.prototype.isMouseOver = function () {
	var r2 = Math.pow(mouse.worldX - this.x, 2) + Math.pow(mouse.worldY - this.y, 2);

	if (r2 < Math.pow(this.radius + 20, 2)) {
		this.hover = true;

		if (mouse.isMouseDown) {
			// TODO
			s1 = 0;
			star = net.starList[s1];
			net.starList[s1].setPoints(net.starList[s1].points - 1);

			var Ox = (star.x - this.x) * 0.5;
			var Oy = (star.y - this.y) * 0.5;
			var R = Math.sqrt(Math.pow(Ox, 2) + Math.pow(Oy, 2));
			var alpha0 = 2 * Math.asin(star.radius / R * 0.5);
			var alpha = alpha0;
			var id = star.id;

			var gamma = Math.acos(Ox / R);

			if (Oy < 0) {
				gamma = -gamma;
			}

			this.shipList.push([s1, Ox, Oy, R, alpha, alpha0, gamma, id]);
		}
	} else {
		this.hover = false;
	}

	return this.hover;
};

/*
The network is made of interconnected stars. This handles the lists of relevant items
and updates the networks's state
*/
function Network(size) {
	this.mapSize = 1000;
	this.size = size;
	this.nSatellites = 50;

	// Initialize the network of stars
	this.starList = generateStars(this.size);
	this.satelliteList = generateSatellites(this.nSatellites, this.mapSize);

	this.nStars = this.starList.length;

	colorList.push(["hsl(180, 0%, 51%)", "hsl(180, 0%, 67%)"],
						generateColor(220), generateColor(100));

	// Contains the connexions
	this.connexionList = [];

	// var c = computeBridge(this.starList[0], this.starList[1])
	// start star, end star, val, proportion, length, theta, id
	this.shipList = [];

	// x, y, value

	this.automationList = [];

	this.addNewShip = function (s1, s2, val) {
		var star1 = this.starList[s1];
		var star2 = this.starList[s2];

		var dx = star2.x - star1.x;
		var dy = star2.y - star1.y;
		var L = Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));
		var c = star1.radius / L;
		var id = star1.id;

		var theta = Math.acos(dx / L);

		if (dy < 0) {
			theta = -theta;
		}

		this.shipList.push([s1, s2, val, c, L, theta, id]);
	};
}

Network.prototype.update = function (dt) {
	// Compute the new advancement of the ships, plus the conquest mechanic

	for (var i = this.shipList.length - 1; i >= 0; i--) {
		// New proportion of the segment crossed
		var c = this.shipList[i][3] + shipSpeed * dt / this.shipList[i][4];

		if (c < (this.shipList[i][4] - this.starList[this.shipList[i][1]].radius) / this.shipList[i][4]) {
			this.shipList[i][3] = c;
		} else {
			var p = this.starList[this.shipList[i][1]].points;
			var star1 = this.starList[this.shipList[i][0]];
			var star2 = this.starList[this.shipList[i][1]];

			// Both stars belong to the same player

			if (star1.id == star2.id) {
				star2.setPoints(p + this.shipList[i][2]);
			} else {
				var q = p - this.shipList[i][2];

				// The star is attacked, if the score is neg, the star is conquered

				if (q < 0) {
					star2.setPoints(-q - 1);
					star2.id = this.shipList[i][6];
				} else {
					star2.setPoints(q);
				}
			}

			this.shipList.splice(i, 1);
		}
	}
};

Network.prototype.draw = function () {
	// Draws the connexions between stars according to their colors

	for (var i = 0; i < this.connexionList.length; i++) {
		ctx.save();

		var s1 = this.starList[this.connexionList[i][0]];
		var s2 = this.starList[this.connexionList[i][1]];

		translate(s1.x, s1.y);
		ctx.setLineDash([20, 8]);

		ctx.lineWidth = 3;

		if (s1.id == s2.id) {
			ctx.strokeStyle = colorList[s1.id][0];
		} else {
			ctx.strokeStyle = whiteColor;
		}

		ctx.beginPath();
		ctx.moveTo(0, 0);
		ctx.lineTo(s2.x - s1.x, s2.y - s1.y);
		ctx.stroke();
		ctx.closePath();

		ctx.restore();
	}

	// Draws the automation indicator

	for (i = 0; i < this.automationList.length; i++) {
		var star1 = net.starList[this.automationList[i][0]];
		var star2 = net.starList[this.automationList[i][1]];
		var dx = star2.x - star1.x;
		var dy = star2.y - star1.y;
		var L = Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));

		var theta = Math.acos(dx / L);

		if (dy < 0) {
			theta = -theta;
		}

		var c = Math.cos(theta);
		var s = Math.sin(theta);
		var h = star1.radius + 60;

		ctx.save();

		translate(star1.x, star1.y);
		ctx.fillStyle = colorList[star1.id][0];

		ctx.beginPath();
		ctx.moveTo(-25 * s, 25 * c);
		ctx.lineTo(h * c, h * s);
		ctx.lineTo(25 * s, -25 * c);
		ctx.lineTo(0, 0);
		ctx.fill();

		ctx.restore();
	}

	// Draws the ships

	for (i = 0; i < this.shipList.length; i++) {
		var connectionLength = this.shipList[i][4];
		var k = this.shipList[i][3];
		var connectionAngle = this.shipList[i][5];
		var id = this.starList[this.shipList[i][0]].id;

		var x = this.starList[this.shipList[i][0]].x + connectionLength * k * Math.cos(connectionAngle);
		var y = this.starList[this.shipList[i][0]].y + connectionLength * k * Math.sin(connectionAngle);

		drawShip(this.shipList[i][6], x, y, connectionAngle, this.shipList[i][2], 1, false);
	}

	// Draws the stars

	for (i = 0; i < this.nStars; i++) {
		this.starList[i].draw();
	}

	// Draws the satellites

	for (i = 0; i < this.nSatellites; i++) {
		var sat = this.satelliteList[i];

		ctx.save();

		translate(sat.x, sat.y);
		ctx.fillStyle = whiteColor;
		ctx.shadowColor = whiteColor;
		ctx.shadowBlur = 5;
		ctx.strokeStyle = whiteSemiColor;
		ctx.lineWidth = 4;

		ctx.beginPath();
		ctx.arc(0, 0, sat.radius, 0, Math.PI * 2);
		ctx.fill();
		ctx.stroke();

		ctx.restore();
	}
};

/*
Handles the star. It is defined with a position and a score, whose image
is the radius of the star. It can be selected or hovered. Special items
are drawn in those cases.
*/
function Star(id, x, y, points) {
	this.id = id;
	this.x = x;
	this.y = y;
	this.points = points;

	this.radius = 45 + Math.log(this.points + 1) * 5;

	// State of the star
	this.hover = false;
	this.select = false;
}

// Update the score of the star
Star.prototype.setPoints = function (p) {
	this.points = p;
	this.radius = 45 + Math.log(this.points + 1) * 6;
};

// Draw the star on the screen
Star.prototype.draw = function () {
	ctx.save();
	translate(this.x, this.y);

	ctx.beginPath();
	ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
	ctx.fillStyle = colorList[this.id][0];
	ctx.strokeStyle = colorList[this.id][1];
	ctx.lineWidth = 6;
	ctx.shadowColor = colorList[this.id][1];

	// Blur if hovered
	if (!this.hover) {
		ctx.shadowBlur = 0;
	} else {
		ctx.shadowBlur = 12;
	}
	ctx.shadowBlur = 0;
	ctx.fill();
	ctx.stroke();
	ctx.closePath();

	// Reflection effect
	ctx.shadowBlur = 0;
	ctx.beginPath();
	var r = this.radius - 9;
	ctx.fillStyle = whiteTransparentColor;
	ctx.arc(0, 0, r, Math.PI, 0);
	ctx.arc(0, -Math.sqrt(3) * r, 2 * r, Math.PI / 3.0, 2 * Math.PI / 3.0);
	ctx.fill();
	ctx.closePath();

	// Write the score
	var s = parseInt(this.radius);
	ctx.font = "lighter " + String(s) + "px arial";
	ctx.fillStyle = whiteSemiColor;
	ctx.textAlign = "center";
	ctx.textBaseline = "middle";
	ctx.fillText(this.points, 0, 5);

	ctx.restore();
};

// Determine if the mouse is over the star
Star.prototype.isMouseOver = function () {
	var r2 =	Math.pow(mouse.worldX - this.x, 2) +
				Math.pow(mouse.worldY - this.y, 2);

	if (r2 < Math.pow(this.radius * 1.7, 2)) {
		this.hover = true;
	} else {
		this.hover = false;
	}

	return this.hover;
};

// Very WEIRD stuff
function downHandler(e) {
	mouse.downHandler(e);
}

function upHandler(e) {
	mouse.upHandler(e);
}

function wheelHandler(e) {
	mouse.wheelHandler(e);
}

function moveHandler(e) {
	mouse.moveHandler(e);
}

function keyDownHandler(e) {
	if (e.keyCode == 39) {
		rightPressed = true;
	} else if (e.keyCode == 37) {
		leftPressed = true;
	}
}

function keyUpHandler(e) {
	if (e.keyCode == 39) {
		rightPressed = false;
	} else if (e.keyCode == 37) {
		leftPressed = false;
	}
}

document.addEventListener("keydown", keyDownHandler, false);
document.addEventListener("keyup", keyUpHandler, false);

net = new Network(3);
d = new Dot(100, 100, 3);
space = new SpaceBackground(100);
player = new Player(1);
mouse = new Mouse();
// worldMousePosition();

// Connect events
document.addEventListener("mousedown", downHandler, false);
document.addEventListener("mouseup", upHandler, false);
document.addEventListener("DOMMouseScroll", wheelHandler, false);
document.addEventListener("mousewheel", wheelHandler, false);
document.addEventListener("mousemove", moveHandler, false);

time = null;
globalTimer = null;

function draw(timestamp) {
	globalTimer = timestamp;

	if (!time) {
		time = timestamp;
	}

	var dt = (timestamp - time) / 1000; // Seconds
	time = timestamp;

	var s = Math.min(player.scale, 1.0);
	ctx.clearRect(0, 0, canvas.width / s, canvas.height / s);
	ctx.save();
	ctx.translate(canvas.width / 2, canvas.height / 2);
	ctx.scale(player.scale, player.scale);

	space.draw();
	player.update();
	player.draw();
	d.draw();
	d.isMouseOver();
	net.update(dt);
	d.update(dt);
	net.draw();

	ctx.restore();

	T += 1;
	requestAnimationFrame(draw);
}

draw();
